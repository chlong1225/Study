package com.demo.algorithm.leetcode.medium;

/**
 * Created by chl on 2023/5/27.
 * description : 大样本统计
 *
 * 我们对0到255之间的整数进行采样，并将结果存储在数组count中：count[k]就是整数k在样本中出现的次数。
 * 计算以下统计数据:
 * minimum：样本中的最小元素。
 * maximum：样品中的最大元素。
 * mean：样本的平均值，计算为所有元素的总和除以元素总数。
 * median：
 * 如果样本的元素个数是奇数，那么一旦样本排序后，中位数 median 就是中间的元素。
 * 如果样本中有偶数个元素，那么中位数median 就是样本排序后中间两个元素的平均值。
 * mode：样本中出现次数最多的数字。保众数是唯一 的。
 * 以浮点数数组的形式返回样本的统计信息[minimum, maximum, mean, median, mode]。与真实答案误差在10-5内的答案都可以通过。
 *
 * 示例 1：
 * 输入：count = [0,1,3,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
 * 输出：[1.00000,3.00000,2.37500,2.50000,3.00000]
 * 解释：用count表示的样本为[1,2,2,2,3,3,3,3]。
 * 最小值和最大值分别为1和3。
 * 均值是(1+2+2+2+3+3+3+3) / 8 = 19 / 8 = 2.375。
 * 因为样本的大小是偶数，所以中位数是中间两个元素2和3的平均值，也就是2.5。
 * 众数为3，因为它在样本中出现的次数最多。
 *
 * 示例 2：
 * 输入：count = [0,4,3,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
 * 输出：[1.00000,4.00000,2.18182,2.00000,1.00000]
 * 解释：用count表示的样本为[1,1,1,1,2,2,3,3,3,4,4]。
 * 最小值为1，最大值为4。
 * 平均数是(1+1+1+1+2+2+2+3+3+4+4)/ 11 = 24 / 11 = 2.18181818…(为了显示，输出显示了整数2.18182)。
 * 因为样本的大小是奇数，所以中值是中间元素2。
 * 众数为1，因为它在样本中出现的次数最多。
 *
 * 提示：
 * count.length == 256
 * 0 <= count[i] <= 10^9
 * 1 <= sum(count) <= 10^9
 * count的众数是唯一的
 */
public class SampleStats {

    public double[] sampleStats(int[] count) {
        int n = count.length;
        int min = -1;
        int max = -1;
        long sum = 0;
        long base = 1;
        int sumCount = 0;
        int maxCount = 0;
        int mode = 0;
        for (int i = 0; i < n; i++) {
            if (count[i] != 0) {
                sumCount += count[i];
                sum += (base * i * count[i]);
                if (min == -1) {
                    min = i;
                    max = i;
                } else {
                    max = i;
                }
                if (maxCount < count[i]) {
                    maxCount = count[i];
                    mode = i;
                }
            }
        }
        double mean = sum * 1.0 / sumCount;
        //再次遍历查找中间值
        double middle = 0;
        if (sumCount % 2 == 0) {
            //偶数个，取中间平均值
            int index1 = sumCount / 2;
            int index2 = index1 - 1;
            boolean findSmall = false;
            for (int i = 0; i < n; i++) {
                if (count[i] != 0) {
                    if (!findSmall) {
                        if (index2 < count[i]) {
                            middle += i;
                            findSmall = true;
                        } else {
                            index2 -= count[i];
                        }
                    }
                    if (index1 < count[i]) {
                        middle += i;
                        break;
                    } else {
                        index1 -= count[i];
                    }
                }
            }
            middle /= 2;
        } else {
            int index = sumCount / 2;
            for (int i = 0; i < n; i++) {
                if (count[i] != 0) {
                    if (index < count[i]) {
                        middle = i;
                        break;
                    } else {
                        index -= count[i];
                    }
                }
            }
        }
        return new double[]{min, max, mean, middle, mode};
    }


}
